package com.coreoz.plume.admin;

import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.regex.Pattern;

import com.coreoz.plume.admin.services.logapi.LogInterceptApiBean;

import com.google.common.base.Strings;
import okhttp3.Request;
import okhttp3.Response;

/**
 * Represent an operation that transforms the trace generated by {@link OkHttpLoggerInterceptor}
 * <p>
 * This is a functional interface</a>
 * whose functional method is {@link #transform(Request, Response, LogInterceptApiBean)}.
 * <p>
 * The static method {@link #limitBodySizeTransformer(int)} transforms the body of either the request or the response
 * to be truncated at a given limit
 */
@FunctionalInterface
public interface LogEntryTransformer {
    LogInterceptApiBean transform(Request request, Response response, LogInterceptApiBean trace);

    default LogEntryTransformer andApply(LogEntryTransformer otherTransformerToApplyAfter) {
        return (request, response, apiTrace) -> otherTransformerToApplyAfter
            .transform(request, response, transform(request, response, apiTrace));
    }

    default LogEntryTransformer applyOnlyToRequests(RequestPredicate allowRequestPredicate) {
        return (request, response, apiTrace) ->
            allowRequestPredicate.test(request) ?
                transform(request, response, apiTrace)
                : apiTrace;
    }

    default LogEntryTransformer applyOnlyToResponses(Predicate<Response> allowResponsePredicate) {
        return (request, response, apiTrace) ->
            allowResponsePredicate.test(response) ?
                transform(request, response, apiTrace)
                : apiTrace;
    }

    default LogEntryTransformer applyOnlyToResponsesWithHeader(String headerName, String headerValue) {
        return applyOnlyToResponses(
            response -> OkHttpMatchers.matchResponseHeaders(response.headers(), headerName, headerValue)
        );
    }

    static LogEntryTransformer limitBodySizeTransformer(int bodyCharLengthLimit) {
        return (request, response, apiTrace) -> {
            if (bodyCharLengthLimit < 0) {
                return apiTrace;
            }
            String bodyRequest = apiTrace.getBodyRequest();
            if (bodyRequest != null && bodyRequest.length() > bodyCharLengthLimit) {
                apiTrace.setBodyRequest(bodyRequest.substring(0, bodyCharLengthLimit));
            }
            String bodyResponse = apiTrace.getBodyResponse();
            if (bodyResponse != null && bodyResponse.length() > bodyCharLengthLimit) {
                apiTrace.setBodyResponse(bodyResponse.substring(0, bodyCharLengthLimit));
            }
            return apiTrace;
        };
    }

    static LogEntryTransformer nullifyBodyForUrlRegexList(List<String> urlRegexList) {
        Objects.requireNonNull(urlRegexList);

        if (urlRegexList.isEmpty()) {
            return LogEntryTransformer.emptyTransformer();
        }

        Pattern compiledRegex = Pattern.compile(RegexBuilder.computeUrlRegexList(urlRegexList));

        return (request, response, apiLogEntry) -> {
            if (compiledRegex.matcher(apiLogEntry.getUrl()).matches()) {
                if (!Strings.isNullOrEmpty(apiLogEntry.getBodyRequest())) {
                    apiLogEntry.setBodyRequest(null);
                }
                if (!Strings.isNullOrEmpty(apiLogEntry.getBodyResponse())) {
                    apiLogEntry.setBodyResponse(null);
                }
            }
            return apiLogEntry;
        };
    }

    static LogEntryTransformer emptyTransformer() {
        return (request, response, apiTrace) -> apiTrace;
    }
}
